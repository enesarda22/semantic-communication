Index: train_end_to_end.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import argparse\nimport os\n\nimport numpy as np\nimport torch\nfrom tqdm import tqdm\n\nfrom semantic_communication.data_processing.data_handler import DataHandler\nfrom semantic_communication.models.transceiver import (\n    TxRelayChannelModel,\n    TxRelayRxChannelModel,\n    Transceiver,\n    RelayChannelBlock,\n)\nfrom semantic_communication.utils.channel import (\n    init_channel,\n    get_distance,\n)\nfrom semantic_communication.models.semantic_decoder import SemanticDecoder\nfrom semantic_communication.models.semantic_encoder import SemanticEncoder\nfrom semantic_communication.utils.general import (\n    get_device,\n    print_loss,\n    create_checkpoint,\n    set_seed,\n    add_semantic_decoder_args,\n    add_channel_model_args,\n    add_data_args,\n    add_train_args,\n    load_model,\n    load_optimizer,\n)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--transceiver-path\", type=str)\n\n    # semantic decoders\n    parser.add_argument(\"--relay-channel-block-path\", type=str)\n    parser.add_argument(\"--receiver-decoder-path\", type=str)\n    add_semantic_decoder_args(parser)\n\n    # channel models\n    parser.add_argument(\"--tx-relay-rx-channel-model-path\", type=str)\n    add_channel_model_args(parser)\n\n    add_data_args(parser)\n    add_train_args(parser)\n    args = parser.parse_args()\n\n    set_seed()\n    device = get_device()\n\n    semantic_encoder = SemanticEncoder(max_length=args.max_length)\n    data_handler = DataHandler(\n        semantic_encoder=semantic_encoder,\n        batch_size=args.batch_size,\n        data_fp=args.data_fp,\n    )\n\n    relay_decoder = SemanticDecoder(\n        vocab_size=data_handler.vocab_size,\n        n_blocks=args.n_blocks,\n        n_heads=args.n_heads,\n        n_embeddings=args.n_embeddings,\n        block_size=args.max_length,\n    ).to(device)\n\n    channel = init_channel(args.channel_type, args.sig_pow, args.alpha, args.noise_pow)\n    tx_relay_channel_enc_dec = TxRelayChannelModel(\n        nin=args.channel_block_input_dim,\n        n_latent=args.channel_block_latent_dim,\n        channel=channel,\n    ).to(device)\n\n    relay_channel_block = RelayChannelBlock(\n        semantic_decoder=relay_decoder,\n        tx_relay_channel_enc_dec=tx_relay_channel_enc_dec,\n    ).to(device)\n    load_model(relay_channel_block, args.relay_channel_block_path)\n\n    receiver_decoder = SemanticDecoder(\n        vocab_size=data_handler.vocab_size,\n        n_blocks=args.n_blocks,\n        n_heads=args.n_heads,\n        n_embeddings=args.n_embeddings * 2,\n        block_size=args.max_length,\n    ).to(device)\n    load_model(receiver_decoder, args.receiver_decoder_path)\n\n    tx_relay_rx_channel_model = TxRelayRxChannelModel(\n        nin=args.channel_block_input_dim,\n        n_latent=args.channel_block_latent_dim,\n        channel=channel,\n    ).to(device)\n    load_model(tx_relay_rx_channel_model, args.tx_relay_rx_channel_model_path)\n\n    transceiver = Transceiver(\n        semantic_encoder=semantic_encoder,\n        relay_channel_block=relay_channel_block,\n        rx_semantic_decoder=receiver_decoder,\n        tx_relay_rx_channel_enc_dec=tx_relay_rx_channel_model,\n        encoder=data_handler.encoder,\n    )\n    load_model(transceiver, args.transceiver_path)\n\n    optimizer = torch.optim.AdamW(transceiver.parameters(), lr=args.lr)\n    load_optimizer(optimizer, args.transceiver_path)\n\n    best_loss = torch.inf\n    for epoch in range(args.n_epochs):\n        train_losses = []\n        transceiver.train()\n        for b in tqdm(data_handler.train_dataloader):\n            xb = b[0].to(device)\n            targets = data_handler.encode_token_ids(xb)\n            attention_mask = b[1].to(device)\n\n            d_sd = get_distance(args.d_min, args.d_max)\n            d_sr = get_distance(d_sd * args.gamma_min, d_sd * args.gamma_max)\n            d_rd = d_sd - d_sr\n\n            logits, loss = transceiver(\n                xb, attention_mask, targets[:, 1:], d_sd, d_sr, d_rd\n            )\n\n            optimizer.zero_grad(set_to_none=True)\n            loss.backward()\n            optimizer.step()\n            train_losses.append(loss.item())\n\n        val_losses = []\n        transceiver.eval()\n        for b in data_handler.val_dataloader:\n            xb = b[0].to(device)\n            targets = data_handler.encode_token_ids(xb)\n            attention_mask = b[1].to(device)\n\n            d_sd = get_distance(args.d_min, args.d_max)\n            d_sr = get_distance(d_sd * args.gamma_min, d_sd * args.gamma_max)\n            d_rd = d_sd - d_sr\n            with torch.no_grad():\n                _, loss = transceiver(\n                    xb, attention_mask, targets[:, 1:], d_sd, d_sr, d_rd\n                )\n\n            val_losses.append(loss.item())\n\n        print(\"\\n\")\n        print_loss(train_losses, \"Train\")\n        print_loss(val_losses, \"Val\")\n\n        mean_loss = np.mean(val_losses)\n\n        checkpoint_path = os.path.join(\n            args.checkpoint_path,\n            f\"end-to-end-transceiver/end_to_end_transceiver_{epoch}.pt\",\n        )\n\n        if mean_loss < best_loss:\n            create_checkpoint(\n                path=checkpoint_path,\n                model_state_dict=transceiver.state_dict(),\n                optimizer_state_dict=optimizer.state_dict(),\n                mean_val_loss=mean_loss,\n            )\n            best_loss = mean_loss\n        else:\n            create_checkpoint(\n                path=checkpoint_path,\n                model_state_dict=None,\n                optimizer_state_dict=None,\n                mean_val_loss=mean_loss,\n            )\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/train_end_to_end.py b/train_end_to_end.py
--- a/train_end_to_end.py	(revision 4fd60ad541774a4b3c1f66bdc932b08b0b4b8445)
+++ b/train_end_to_end.py	(date 1701105196376)
@@ -79,6 +79,11 @@
     ).to(device)
     load_model(relay_channel_block, args.relay_channel_block_path)
 
+    # TODO: no scheduler or freeze
+    # freeze
+    for param in relay_channel_block.parameters():
+        param.requires_grad = False
+
     receiver_decoder = SemanticDecoder(
         vocab_size=data_handler.vocab_size,
         n_blocks=args.n_blocks,
